# FFA Investments — Runbook & Repo Summary
Date: 2025-11-21

This document records the current project state, a compact directory tree, and a reproducible runbook to recreate the project and the Supabase RPC `api_get_member_feed`. Save this file in `docs/` so other developers or an automated agent can re-create the Supabase side and understand how the frontend expects the RPC to behave.

---

## Current status (high level)
- Frontend: React + Vite app in `src/` with protected routes and an AuthContext backed by Supabase.
- Backend: Supabase (Auth + Postgres). A server-side RPC `api_get_member_feed` has been added under `database/rpc/api_get_member_feed.sql` to provide an enriched feed so the frontend no longer needs to join profiles or check per-post likes.
- Member Feed: `src/Pages/MemberFeed/MemberFeed.jsx` uses `src/lib/ffaApi.js::getMemberFeed()` which now calls the RPC and returns { posts, nextCursor }.
- Deploy: Vercel; builds with `npm run build` (Vite). Production deploys have been done via `npx vercel --prod`.

Key files changed/added in this session:
- `src/lib/ffaApi.js` — `getMemberFeed` now calls the RPC `api_get_member_feed` and maps returned rows into `posts` and `nextCursor`.
- `src/Pages/MemberFeed/MemberFeed.jsx` — feed now consumes enriched posts from `getMemberFeed`, PostCard uses `author_name`, `like_count`, `comment_count`, and `liked_by_me` returned by the RPC. PostComposer uploads images to `member-post-images` with uploader metadata.
- `src/Layout.jsx` — added Member Feed navigation link.
- `database/rpc/api_get_member_feed.sql` — SQL function that returns enriched feed rows (cursor pagination, counts, liked_by_me using `auth.uid()`).

---

## Directory tree (concise, key files)
Root (c:\Users\AceGr\FFAinvestments)
```
.
├── .env
├── package.json
├── vite.config.js
├── vercel.json
├── README.md
├── src/
│   ├── App.jsx
│   ├── Layout.jsx
│   ├── main.jsx
│   ├── index.css
│   ├── lib/
│   │   ├── supabase.js
│   │   └── ffaApi.js
│   ├── contexts/
│   │   └── AuthContext.jsx
│   ├── Pages/
│   │   ├── MemberFeed/
│   │   │   └── MemberFeed.jsx
│   │   ├── AdminDues/
│   │   │   └── index.jsx
│   │   ├── Settings/
│   │   │   └── SettingsPage.jsx
│   │   ├── AdminUnitPrice.jsx (component)
│   │   └── ... (other pages)
│   └── components/
│       └── ModernLogin.jsx
├── database/
│   └── rpc/
│       └── api_get_member_feed.sql
├── docs/
│   └── RUNBOOK_2025-11-21.md  <-- (this file)
└── dist/ (build output)
```

Note: For a full tree see `directory-structure.txt` in the repo root (generated earlier during development).

---

## The RPC — what it does (summary)
- Name: `public.api_get_member_feed(limit_count integer DEFAULT 20, cursor_timestamp timestamptz DEFAULT NULL)`
- Returns `TABLE(post_id uuid, author_id uuid, author_name text, content text, image_url text, link_url text, visibility text, created_at timestamptz, like_count bigint, comment_count bigint, liked_by_me boolean, next_cursor_timestamp timestamptz)`
- Behavior:
  - Reads posts from `member_posts` ordered by `created_at DESC`.
  - Applies cursor pagination: if `cursor_timestamp` is provided it returns posts with `created_at < cursor_timestamp`.
  - Returns up to `limit_count` rows. The function internally fetches `limit_count + 1` rows to determine if there is a next page and sets `next_cursor_timestamp` to the created_at of the last row when more pages exist.
  - For each post the function returns:
    - `author_name` from `profiles` (`display_name`, `full_name`, `name` fallback)
    - `like_count` (COUNT from `member_post_likes`)
    - `comment_count` (COUNT from `member_post_comments`)
    - `liked_by_me` — computed as EXISTS(...) comparing `member_post_likes.member_id = auth.uid()` so the RPC respects the calling Supabase user's identity.
  - Visibility rules: returns posts with `visibility = 'club'` for authenticated users; `visibility = 'admin'` only included if user's `profiles.role = 'admin'`.

Implementation note: the SQL file is at `database/rpc/api_get_member_feed.sql` (STABLE PL/pgSQL). It uses `auth.uid()` to reference the calling user and does not use SECURITY DEFINER so RLS continues to apply normally.

---

## How the frontend uses the RPC
- `src/lib/ffaApi.js::getMemberFeed({ limit, cursor })` calls:

```js
const { data, error } = await supabase.rpc('api_get_member_feed', {
  limit_count: limit,
  cursor_timestamp: cursor || null,
})
```

- `getMemberFeed` maps RPC rows into `{ posts, nextCursor }` where each `post` contains the enriched fields the frontend expects (`author_name`, `like_count`, `comment_count`, `liked_by_me`, etc.).
- `src/Pages/MemberFeed/MemberFeed.jsx` loads initial posts with `getMemberFeed({ limit: 20 })`, renders `PostComposer` and a list of `PostCard`s. For pagination it calls `getMemberFeed({ limit: 20, cursor: nextCursor })` and appends posts.
- `PostCard` uses the fields provided by the RPC:
  - `post.author_name` for display,
  - `post.like_count` and `post.comment_count` for counts,
  - `post.liked_by_me` to initialize like button state.

---

## Reproducible Runbook — recreate Supabase & wire app
Below are step-by-step instructions to create a Supabase project, apply the schema pieces used by the feed code, create the RPC, and run the app locally and deploy.

Prerequisites:
- Node.js (>= 18), npm
- Supabase account and `supabase` CLI (optional but recommended)
- Vercel account and `vercel` CLI (for production deploy)

1) Create Supabase project
  - Go to https://app.supabase.com and create a new project.
  - Save the Project URL and anon/public key.
  - Configure a service_role key for migrations if needed (keep it secret).

2) Create core database tables (minimum required for feed)
  - Run these SQL statements in Supabase SQL editor or via psql (replace with your DB endpoint credentials):

```sql
-- member_posts
CREATE TABLE IF NOT EXISTS public.member_posts (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  author_id uuid NOT NULL,
  content text,
  image_url text,
  link_url text,
  visibility text DEFAULT 'club',
  created_at timestamptz DEFAULT now()
);

-- member_post_likes
CREATE TABLE IF NOT EXISTS public.member_post_likes (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  post_id uuid REFERENCES public.member_posts(id) ON DELETE CASCADE,
  member_id uuid NOT NULL,
  created_at timestamptz DEFAULT now(),
  UNIQUE (post_id, member_id)
);

-- member_post_comments
CREATE TABLE IF NOT EXISTS public.member_post_comments (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  post_id uuid REFERENCES public.member_posts(id) ON DELETE CASCADE,
  author_id uuid NOT NULL,
  content text,
  created_at timestamptz DEFAULT now()
);

-- profiles (basic)
CREATE TABLE IF NOT EXISTS public.profiles (
  id uuid PRIMARY KEY, -- this should match auth.uid()
  email text,
  display_name text,
  full_name text,
  name text,
  role text DEFAULT 'member'
);

-- storage bucket (manually via Supabase Storage UI or CLI)
-- Create bucket: member-post-images (public read or storage policies as required)
```

3) Apply RPC (server-side enriched feed)
  - Open `database/rpc/api_get_member_feed.sql` from this repo and run that SQL in Supabase SQL editor or via `psql`.
  - Confirm the function exists by running:

```sql
SELECT proname, prosrc FROM pg_proc p JOIN pg_namespace n ON p.pronamespace = n.oid WHERE proname = 'api_get_member_feed';
```

4) RLS policies and auth
  - Ensure your `profiles` table is accessible through your row-level policies and that your RLS allows `auth.uid()` to match `profiles.id` for lookups.
  - Typical pattern: `profiles.id = auth.uid()` and policies for `member_posts`, `member_post_likes`, `member_post_comments` to allow authenticated users to insert/select.

5) Frontend wiring
  - Set environment variables in `.env`:

```
VITE_SUPABASE_URL=https://<project>.supabase.co
VITE_SUPABASE_ANON_KEY=<anon_public_key>
```

  - Run local dev server:

```powershell
npm install
npm run dev
```

6) Test the feed locally
  - Create an account (or use seeded test users). Ensure `profiles` rows exist for users with `id = auth.uid()`.
  - Log in and visit `/member/feed`.
  - Test posting text-only, link-only, and image posts. Image uploads will go to the `member-post-images` bucket (make sure the bucket exists and policies allow upload for authenticated users). The composer will upload with metadata `uploader` set to the user id.
  - Test liking/unliking — `member_post_likes` should be updated and liked state reflected by RPC results.

7) Build and deploy to production

```powershell
npm run build
npx vercel --prod
```

Make sure Vercel environment variables mirror `.env` (Supabase URL and ANON key).

---

## Verification checklist
- [ ] `api_get_member_feed` exists in Supabase and returns data for authenticated calls.
- [ ] Frontend `getMemberFeed` returns objects with `author_name`, `like_count`, `comment_count`, `liked_by_me`.
- [ ] Posting a new post appears in the feed for the author and other members (visibility 'club').
- [ ] Liking a post toggles `member_post_likes`, and RPC shows liked_by_me for the liking user.
- [ ] Pagination `Load more` loads post pages using `nextCursor` returned by `getMemberFeed`.

---

## Troubleshooting notes
- If `liked_by_me` is always false, ensure `member_post_likes.member_id` uses the same id as `auth.uid()` (usually `profiles.id` equals `auth.uid()`). If your schema stores a different id (e.g., a `members` table id), adjust the RPC to check against that mapping.
- If `author_name` is missing, check `profiles` entries for posts' `author_id` values.
- For large result sets consider replacing per-row subqueries for counts with a grouped join for performance.

---

If you want, I can also:
- Convert the SQL to a migration script compatible with the Supabase CLI (`supabase db push` or `supabase migration new`).
- Add a test script that uses the Supabase JS client to create test posts/likes/comments and verify RPC responses.

EOF

